use naga::front::glsl::{ErrorKind, ParseErrors};
use std::collections::HashSet;
use std::path::Path;
use std::process::{Command, Stdio};

fn rustfmt_string(input: &str) -> String {
    let mut child = Command::new("rustfmt")
        .arg("--emit")
        .arg("stdout")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("failed to spawn rustfmt");

    {
        use std::io::Write;
        let stdin = child.stdin.as_mut().unwrap();
        stdin.write_all(input.as_bytes()).unwrap();
    }

    let output = child.wait_with_output().unwrap();

    if !output.status.success() {
        eprintln!("rustfmt failed. Returning unformatted code.");
        return input.into();
    }

    String::from_utf8(output.stdout).unwrap()
}

#[rustfmt::skip]
fn is_valid_ext(path: &Path) -> bool {
    path.extension()
        .and_then(|e| e.to_str())
        .is_some_and(|ext| {
            matches!(
                ext,
                "vs" | "fs" | "gs" | "comp"
                    | "vert" | "tesc" | "tese"
                    | "frag" | "geom"
                    | "glsl" | "glslv" | "glslf" | "glslg"
            )
        })
}

struct ShaderInfo {
    filename: String,
    module: naga::Module,
    src: String,
}

/// Recursively traverse `dir` and parse all valid GLSL shaders.
fn collect_shaders(dir: &Path) -> Vec<ShaderInfo> {
    let mut shaders = Vec::new();

    for entry in std::fs::read_dir(dir).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();

        if path.is_dir() {
            shaders.extend(collect_shaders(&path));
            continue;
        }

        if !is_valid_ext(&path) {
            continue;
        }

        let filename = path.file_name().unwrap().to_str().unwrap().to_string();
        let src = std::fs::read_to_string(&path).unwrap();

        let stage = if filename.contains("vert") {
            naga::ShaderStage::Vertex
        } else if filename.contains("frag") {
            naga::ShaderStage::Fragment
        } else {
            continue;
        };

        let mut parser = naga::front::glsl::Frontend::default();
        let module_result = parser.parse(
            &naga::front::glsl::Options {
                stage,
                defines: Default::default(),
            },
            &src,
        );

        let module = match module_result {
            Ok(module) => module,
            Err(ParseErrors { errors }) => {
                for error in errors {
                    if let ErrorKind::NotImplemented(..) = error.kind {
                        eprintln!("Warning: {}", error);
                    } else {
                        panic!("{:?}", error)
                    }
                }
                continue;
            }
        };

        shaders.push(ShaderInfo {
            filename,
            module,
            src,
        });
    }

    shaders
}

fn create_generated_mod() {
    let path = Path::new("src/generated/mod.rs");
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent).unwrap();
    }
    let mut file = std::fs::File::create(path).unwrap();
    std::io::Write::write_all(
        &mut file,
        b"// Auto-generated by build.rs - do not edit\n\nmod shaders;\n\npub use shaders::*;\n",
    )
    .unwrap();
}

fn generate_shader_registry(shaders: Vec<ShaderInfo>) {
    let shaders = HashSet::<String>::from_iter(
        shaders
            .into_iter()
            .map(|s| s.filename.split_once('.').unwrap().0.to_string()),
    );

    let out_path = Path::new("src/generated/shaders.rs");
    std::fs::create_dir_all(out_path.parent().unwrap()).unwrap();

    // Generate shaders.rs
    let mut out = String::from(
        "// Auto-generated by build.rs - DO NOT EDIT
        use glow::{Context, HasContext, NativeProgram};",
    );

    // Program struct
    out.push_str(
        "
        #[derive(Clone, Copy, Debug)]
        pub struct Program {
            native: NativeProgram
        }
        ",
    );

    out.push_str("impl Program {");
    for name in shaders.iter() {
        out.push_str(&format!(
            "pub const fn {}(native: NativeProgram) -> Self {{
             Self {{ native }}}}",
            name.to_lowercase()
        ));
    }
    out.push_str("pub const fn native(&self) -> NativeProgram { self.native }}");

    // Shaders struct
    out.push_str("#[derive(Debug)]\n");
    out.push_str("pub struct Shaders {\n");
    for name in shaders.iter() {
        out.push_str(&format!("pub {}: Program,", name.to_lowercase()));
    }
    out.push('}');

    // impl Shaders
    out.push_str("impl Shaders { pub fn init(gl: &Context) -> crate::Result<Self> {");

    for name in shaders.iter() {
        let vert = Path::new("..")
            .join("..")
            .join("shaders")
            .join(format!("{name}.vert"));
        let frag = Path::new("..")
            .join("..")
            .join("shaders")
            .join(format!("{name}.frag"));

        out.push_str(&format!(
            "let {name}_sources = [
                (glow::VERTEX_SHADER, include_str!({vert:?})),
                (glow::FRAGMENT_SHADER, include_str!({frag:?})),
             ];
             let {name}_prog = process_shaders(gl, {name}_sources)?;
             let {name} = Program::{name}({name}_prog);",
        ));
    }

    out.push_str("        Ok(Self {");
    for name in shaders.iter() {
        out.push_str(&format!("            {name},"));
    }
    out.push_str("})}");

    // Getters
    for name in shaders.iter() {
        let func_name = name.to_lowercase();
        out.push_str(&format!(
            "pub const fn {func_name}(&self) -> &Program {{ &self.{func_name} }}",
        ));
    }

    // Delete method
    out.push_str("pub fn delete(self, gl: &glow::Context) {");
    for name in shaders.iter() {
        let func_name = name.to_lowercase();
        out.push_str(&format!(
            "unsafe {{ gl.delete_program(self.{func_name}.native()) }}",
        ));
    }
    out.push_str("}}");

    // process_shaders()
    out.push_str(r#"
        fn process_shaders(gl: &Context, shader_sources: [(u32, &str); 2]) -> crate::Result<NativeProgram> {
            let program = unsafe { gl.create_program().map_err(|e| anyhow::anyhow!(e))? };
            let mut shaders = Vec::with_capacity(shader_sources.len());
            for (shader_type, shader_source) in shader_sources {
                unsafe {
                    let shader = gl.create_shader(shader_type).map_err(|e| anyhow::anyhow!(e))?;
                    gl.shader_source(shader, shader_source);
                    gl.compile_shader(shader);
                    if !gl.get_shader_compile_status(shader) {
                        panic!("{}", gl.get_shader_info_log(shader));
                    }
                    gl.attach_shader(program, shader);
                    shaders.push(shader);
                }
            }
            unsafe {
                gl.link_program(program);
                if !gl.get_program_link_status(program) {
                    panic!("{}", gl.get_program_info_log(program));
                }
                for shader in shaders {
                    gl.detach_shader(program, shader);
                    gl.delete_shader(shader);
                }
            }
            Ok(program)
        }
    "#);

    // format just before writing to file
    let out = rustfmt_string(&out);

    std::fs::write(out_path, out).unwrap();
    println!("[x] Generated shaders.rs ({} shaders)", shaders.len());
}

fn main() {
    #[cfg(target_os = "windows")]
    println!("cargo:rustc-link-lib=advapi32");

    println!("cargo:rerun-if-changed=shaders");

    let shader_dir = Path::new("shaders");
    std::fs::create_dir_all(shader_dir).unwrap();

    let compiler = shaderc::Compiler::new().expect("Failed to init shaderc");
    let options = shaderc::CompileOptions::new().unwrap();

    let shaders = collect_shaders(shader_dir);

    // Validate
    for shader in &shaders {
        let kind = if shader.filename.contains("vert") {
            shaderc::ShaderKind::Vertex
        } else {
            shaderc::ShaderKind::Fragment
        };

        match compiler.compile_into_spirv(
            &shader.src,
            kind,
            &shader.filename,
            "main",
            Some(&options),
        ) {
            Ok(_) => println!("[x] Shaderc validated: {}", shader.filename),
            Err(e) => panic!(
                "[ ] Shaderc compilation failed ({}):\n{}",
                shader.filename, e
            ),
        }

        let mut validator = naga::valid::Validator::new(
            naga::valid::ValidationFlags::all(),
            naga::valid::Capabilities::all(),
        );
        match validator.validate(&shader.module) {
            Ok(_) => println!("[x] Naga validated: {}", shader.filename),
            Err(e) => panic!("[ ] Naga validation failed ({}):\n{}", shader.filename, e),
        }
    }

    create_generated_mod();
    generate_shader_registry(shaders);
}
