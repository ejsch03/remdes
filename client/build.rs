use naga::front::glsl::{ErrorKind, ParseErrors};
use std::collections::{HashMap, HashSet};
use std::path::Path;

#[rustfmt::skip]
fn is_valid_ext(path: &Path) -> bool {
    path.extension()
        .and_then(|e| e.to_str())
        .is_some_and(|ext| {
            matches!(
                ext,
                "vs" | "fs" | "gs" | "comp"
                    | "vert" | "tesc" | "tese"
                    | "frag" | "geom"
                    | "glsl" | "glslv" | "glslf" | "glslg"
            )
        })
}

struct ShaderInfo {
    filename: String,
    module: naga::Module,
    src: String,
}

/// Recursively traverse `dir` and parse all valid GLSL shaders.
fn collect_shaders(dir: &Path) -> Vec<ShaderInfo> {
    let mut shaders = Vec::new();

    for entry in std::fs::read_dir(dir).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();

        if path.is_dir() {
            shaders.extend(collect_shaders(&path));
            continue;
        }

        if !is_valid_ext(&path) {
            continue;
        }

        let filename = path.file_name().unwrap().to_str().unwrap().to_string();
        let src = std::fs::read_to_string(&path).unwrap();

        let stage = if filename.contains("vert") {
            naga::ShaderStage::Vertex
        } else if filename.contains("frag") {
            naga::ShaderStage::Fragment
        } else {
            continue;
        };

        let mut parser = naga::front::glsl::Frontend::default();
        let module_result = parser.parse(
            &naga::front::glsl::Options {
                stage,
                defines: Default::default(),
            },
            &src,
        );

        let module = match module_result {
            Ok(module) => module,
            Err(ParseErrors { errors }) => {
                for error in errors {
                    if let ErrorKind::NotImplemented(..) = error.kind {
                        eprintln!("Warning: {}", error);
                    } else {
                        panic!("{:?}", error)
                    }
                }
                continue;
            }
        };

        shaders.push(ShaderInfo {
            filename,
            module,
            src,
        });
    }

    shaders
}

fn create_generated_mod() {
    let path = Path::new("src/generated/mod.rs");
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent).unwrap();
    }

    let mut file = std::fs::File::create(path).unwrap();
    std::io::Write::write_all(
        &mut file,
        b"// Auto-generated by build.rs - do not edit\n\nmod uniforms;\nmod shaders;\n\npub use uniforms::*;\npub use shaders::*;\n",
    )
    .unwrap();
}

fn generate_uniform_structs_from_modules(shaders: &[ShaderInfo]) {
    let mut output = String::from(
        "// Auto-generated by build.rs - do not edit\n#![allow(non_upper_case_globals, non_snake_case)]\n",
    );

    let mut shader_map: HashMap<String, String> = Default::default();

    for shader in shaders {
        let shader_name = shader
            .filename
            .split('.')
            .next()
            .unwrap()
            .replace(['-', '.'], "_");

        let shader_body = shader_map.entry(shader_name.clone()).or_default();

        let global_vars = shader.module.global_variables.clone().into_inner();

        for global in global_vars.into_iter() {
            if let naga::AddressSpace::Uniform | naga::AddressSpace::PushConstant = global.space {
                let type_name = shader.module.types[global.ty].name.as_ref().unwrap();
                let var_name = global.name.as_ref().unwrap();
                let binding = global.binding.unwrap().binding;

                shader_body.push_str(&format!("\tpub const {var_name}: u32 = {binding};\n"));

                if let naga::TypeInner::Struct { ref members, .. } =
                    shader.module.types[global.ty].inner
                    && !members.is_empty()
                {
                    shader_body.push_str(&format!("\tpub mod {} {{\n", type_name));
                    for (i, member) in members.iter().enumerate() {
                        let field_name = member.name.as_deref().unwrap_or("unnamed");
                        shader_body.push_str(&format!(
                                "\t\tpub const {field_name}: glow::NativeUniformLocation = glow::NativeUniformLocation({i});\n"
                            ));
                    }
                    shader_body.push_str("\t}\n");
                }
            }
        }
    }

    for (shader_name, body) in shader_map {
        if !body.is_empty() {
            output.push_str(&format!("\npub mod {} {{\n{}\n}}\n", shader_name, body));
        }
    }

    let mut file = std::fs::File::create("src/generated/uniforms.rs").unwrap();
    std::io::Write::write_all(&mut file, output.as_bytes()).unwrap();
}

fn generate_shader_registry(shaders: Vec<ShaderInfo>) {
    fn to_pascal_case(s: &str) -> String {
        let mut out = String::new();
        let mut capitalize = true;
        for c in s.chars() {
            if c == '_' || c == '-' {
                capitalize = true;
            } else if capitalize {
                out.push(c.to_ascii_uppercase());
                capitalize = false;
            } else {
                out.push(c);
            }
        }
        out
    }

    let shaders = HashSet::<String>::from_iter(
        shaders
            .into_iter()
            .map(|s| s.filename.split_once('.').unwrap().0.to_string()),
    );

    let out_path = Path::new("src/generated/shaders.rs");
    std::fs::create_dir_all(out_path.parent().unwrap()).unwrap();

    // Generate shaders.rs
    let mut out = String::from(
        "// Auto-generated by build.rs - DO NOT EDIT\n\
        use glow::{Context, HasContext, NativeProgram};\n\n",
    );

    // Enum ProgramKind
    out.push_str("#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n");
    out.push_str("pub enum ProgramKind {\n");
    for name in shaders.iter() {
        out.push_str(&format!("    {},\n", to_pascal_case(name)));
    }
    out.push_str("}\n\n");

    // Program struct
    out.push_str(
        "#[derive(Clone, Copy, Debug)]\n\
        pub struct Program {\n\
        \tnative: NativeProgram,\n\
        \tkind: ProgramKind,\n\
        }\n\n",
    );

    out.push_str("impl Program {\n");
    for name in shaders.iter() {
        out.push_str(&format!(
            "\tpub const fn {}(native: NativeProgram) -> Self {{\n\
             \t\tSelf {{ native, kind: ProgramKind::{} }}\n\t}}\n\n",
            name.to_lowercase(),
            to_pascal_case(name)
        ));
    }
    out.push_str(
        "\tpub const fn native(&self) -> NativeProgram { self.native }\n\
        \tpub const fn kind(&self) -> ProgramKind { self.kind }\n}\n\n",
    );

    // Shaders struct
    out.push_str("#[derive(Debug)]\n");
    out.push_str("pub struct Shaders {\n");
    for name in shaders.iter() {
        out.push_str(&format!("\tpub {}: Program,\n", name.to_lowercase()));
    }
    out.push_str("}\n\n");

    // impl Shaders
    out.push_str("impl Shaders {\n\tpub fn init(gl: &Context) -> crate::Result<Self> {\n");

    for name in shaders.iter() {
        let vert = Path::new("..")
            .join("..")
            .join("shaders")
            .join(format!("{name}.vert"));
        let frag = Path::new("..")
            .join("..")
            .join("shaders")
            .join(format!("{name}.frag"));

        out.push_str(&format!(
            "\t\tlet {name}_sources = [\n\
             \t\t\t(glow::VERTEX_SHADER, include_str!({vert:?})),\n\
             \t\t\t(glow::FRAGMENT_SHADER, include_str!({frag:?})),\n\
             \t\t];\n\
             \t\tlet {name}_prog = process_shaders(gl, {name}_sources)?;\n\
             \t\tlet {name} = Program::{name}({name}_prog);\n\n",
        ));
    }

    out.push_str("        Ok(Self {\n");
    for name in shaders.iter() {
        out.push_str(&format!("            {name},\n"));
    }
    out.push_str("        })\n    }\n\n");

    // Getters
    for name in shaders.iter() {
        let func_name = name.to_lowercase();
        out.push_str(&format!(
            "\tpub const fn {func_name}(&self) -> &Program {{ &self.{func_name} }}\n",
        ));
    }

    // Delete method
    out.push_str("\n\tpub fn delete(self, gl: &glow::Context) {\n");
    for name in shaders.iter() {
        let func_name = name.to_lowercase();
        out.push_str(&format!(
            "\t\tunsafe {{ gl.delete_program(self.{func_name}.native()) }}\n",
        ));
    }
    out.push_str("\t}\n}\n");

    // process_shaders()
    out.push_str(
        r#"
fn process_shaders(gl: &Context, shader_sources: [(u32, &str); 2]) -> crate::Result<NativeProgram> {
    let program = unsafe { gl.create_program().map_err(|e| anyhow::anyhow!(e))? };
    let mut shaders = Vec::with_capacity(shader_sources.len());
    for (shader_type, shader_source) in shader_sources {
        unsafe {
            let shader = gl.create_shader(shader_type).map_err(|e| anyhow::anyhow!(e))?;
            gl.shader_source(shader, shader_source);
            gl.compile_shader(shader);
            if !gl.get_shader_compile_status(shader) {
                panic!("{}", gl.get_shader_info_log(shader));
            }
            gl.attach_shader(program, shader);
            shaders.push(shader);
        }
    }
    unsafe {
        gl.link_program(program);
        if !gl.get_program_link_status(program) {
            panic!("{}", gl.get_program_info_log(program));
        }
        for shader in shaders {
            gl.detach_shader(program, shader);
            gl.delete_shader(shader);
        }
    }
    Ok(program)
}
"#,
    );

    std::fs::write(out_path, out).unwrap();
    println!("✅ Generated shaders.rs ({} shaders)", shaders.len());
}

fn main() {
    #[cfg(target_os = "windows")]
    println!("cargo:rustc-link-lib=advapi32");

    println!("cargo:rerun-if-changed=shaders");

    let shader_dir = Path::new("shaders");
    std::fs::create_dir_all(shader_dir).unwrap();

    let compiler = shaderc::Compiler::new().expect("Failed to init shaderc");
    let options = shaderc::CompileOptions::new().unwrap();

    let shaders = collect_shaders(shader_dir);

    // Validate
    for shader in &shaders {
        let kind = if shader.filename.contains("vert") {
            shaderc::ShaderKind::Vertex
        } else {
            shaderc::ShaderKind::Fragment
        };

        match compiler.compile_into_spirv(
            &shader.src,
            kind,
            &shader.filename,
            "main",
            Some(&options),
        ) {
            Ok(_) => println!("✅ Shaderc validated: {}", shader.filename),
            Err(e) => panic!(
                "❌ Shaderc compilation failed ({}):\n{}",
                shader.filename, e
            ),
        }

        let mut validator = naga::valid::Validator::new(
            naga::valid::ValidationFlags::all(),
            naga::valid::Capabilities::all(),
        );
        match validator.validate(&shader.module) {
            Ok(_) => println!("✅ Naga validated: {}", shader.filename),
            Err(e) => panic!("❌ Naga validation failed ({}):\n{}", shader.filename, e),
        }
    }

    create_generated_mod();
    generate_uniform_structs_from_modules(&shaders);
    generate_shader_registry(shaders);
}
